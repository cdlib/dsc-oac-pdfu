#!/bin/env python
from lxml.html import parse
import requests
import os
import sys
import logging
import optparse
import boto.utils
import boto
import StringIO
import datetime

import pprint
pp = pprint.PrettyPrinter(indent=4)

DATE_FMT = '%Y-%m-%d %H:%M:%S'

def check_url(url, last_modified_domain, files_to_generate):
    dir, ext = os.path.splitext(url)
    if ext == '.xml':
        check_xml(url, last_modified_domain, files_to_generate)
    elif not ext:
        check_dir(url, last_modified_domain, files_to_generate)

def check_dir(url, last_modified_domain, files_to_generate):
    doc = parse(url).getroot()
    doc.make_links_absolute()
    links = doc.xpath("//a[@href]/@href")
    for link in links:
        if not link == url and link.startswith(url):
            check_url(link, last_modified_domain, files_to_generate)

def check_xml(url, last_modified_domain, files_to_generate):
    r = requests.head(url)
    last_modified_on_oac_header = r.headers['last-modified']
    last_modified_on_oac = boto.utils.parse_ts(last_modified_on_oac_header)
    # if the URL is not in the last_modified_domain OR last-modified is later than the database; add
    # the file to the list of files to be processed
    last_modified_item = last_modified_domain.get_item(url)
    if not last_modified_item:
        if last_modified_on_oac > datetime.datetime(2013,07,01):
            add_to_list(url, last_modified_on_oac, last_modified_domain, files_to_generate)
    elif last_modified_on_oac > datetime.datetime.strptime(last_modified_item['last_modified'], DATE_FMT):
        add_to_list(url, last_modified_on_oac, last_modified_domain, files_to_generate)
        
def add_to_list(url, url_last_modified, last_modified_domain, files_to_generate):
    files_to_generate.append(url)
    # TODO: create/update the simplebd item with the new timestamp and batchID
    logging.info("ADDING TO WORK LIST:%s %s" % (url, url_last_modified))
    attrs = {'last_modified':datetime.datetime.strftime(url_last_modified, DATE_FMT)}
    last_modified_domain.put_attributes(url, attrs)

def launch_ec2(files_to_generate):
    user_data = generate_cloudinit(files_to_generate)
    #use boto to start instance
    conn = boto.connect_ec2('us-east-1')
    reservation = conn.run_instances('ami-05355a6c',
            max_count=1, min_count=1,
            key_name='UCLDC_keypair_0',
            instance_type='m1.large',
            security_groups = ['Solr', 'default'],
            user_data=user_data,
            monitoring_enabled=True,
            instance_profile_name='s3-readonly'
            )
    return

def generate_cloudinit(files_to_generate):
    # generate russian doll bash script
    boilerplate_start="""
#!/bin/bash
# cloudinit script
# https://help.ubuntu.com/community/CloudInit
set -o pipefail  # trace ERR through pipes
set -o errtrace  # trace ERR through 'time command' and other functions
set -o nounset   ## set -u : exit the script if you try to use an uninitialised variable
set -o errexit   ## set -e : exit the script if any statement returns a non-true return value
yum -y update    # for security
yum -y install git
yum -y groupinstall "Development Tools"
easy_install pip
pip install virtualenv
yum -y install python-devel  # needed to install(init?) virtualenv with local python
yum -y install ncurses-devel # needed to install pkgsrc python
yum -y install openssl-devel
yum -y install libjpeg-devel
yum -y install freetype-devel
yum -y install libtiff-devel
yum -y install lcms-devel
yum -y install mercurial

su - ec2-user -c 'curl -L https://raw.github.com/ucldc/appstrap/master/cdl/ucldc-operator-keys.txt >> ~/.ssh/authorized_keys'

useradd pdfu

touch ~pdfu/init.sh
chown pdfu:pdfu ~pdfu/init.sh
chmod 700 ~pdfu/init.sh
# write the file
cat > ~pdfu/init.sh <<EOSETUP
#!/usr/bin/env bash
set -eu
cd
git clone https://github.com/tingletech/pdfu.git
./pdfu/init.sh
xargs -I {} -P 7 -n 1 ./pdfu/pdfu {} <<!
"""
    boilerplate_end="""
!
EOSETUP
su - pdfu -c ~pdfu/init.sh  
rm ~pdfu/init.sh
## TODO: save output of run to a file
## TODO: post log output to an S3 bucket
## TODO: terminate host
"""

    script = StringIO.StringIO()
    script.write(boilerplate_start)
    first = True
    for url in files_to_generate:
        if first:
            first = False
        else:
            script.write("\n")
        s3 = vorotos3url(url)
        script.write(u"%s %s" % ( url, s3 ))
    script.write(boilerplate_end)
    script.seek(0)
    print script.getvalue()

def vorotos3url(url):
    dir, ext = os.path.splitext(url)
    fixup = url.replace('http://voro.cdlib.org/oac-ead/prime2002/','s3://pdf-generation/pdfs/')
    return u"%s.pdf" % ( os.path.splitext(fixup)[0] )

def main(url_check_root, loglevel='ERROR'):
    numeric_level = getattr(logging, loglevel.upper(), None)
    if not isinstance(numeric_level, int):
        raise ValueError('Invalid log level: %s' % argv.loglevel)
    logging.basicConfig(level=numeric_level, )
    url_check_root = url_check_root.strip()
    sdb = boto.connect_sdb()
    last_modified_domain = sdb.get_domain('ead_last_modified')
    files_to_generate = []
    check_url(url_check_root, last_modified_domain, files_to_generate)
# files to generate will be filled up; can now launch an EC2 and run the batch
    if files_to_generate:
        pp.pprint(files_to_generate)
        launch_ec2(files_to_generate)

if __name__=='__main__':
    if len(sys.argv) < 2:
        print "Usage: check_last_modfied <root url to check> --loglevel='DEBUG'"
        sys.exit(1)
    parser = optparse.OptionParser()
    parser.add_option("-l", "--loglevel", dest="loglevel", help="logging module level", default='ERROR')
    (options, args) = parser.parse_args()
    main(args[0], loglevel=options.loglevel)
