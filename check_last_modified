#!/bin/env python
from lxml.html import parse
import requests
import os
import sys
import logging
import optparse
import boto.utils
import boto
import datetime
from time import sleep

from pprint import pprint as pp

DATE_FMT = '%Y-%m-%d %H:%M:%S'

def check_url(url, last_modified_domain, files_to_generate):
    dir, ext = os.path.splitext(url)
    if ext == '.xml':
        check_xml(url, last_modified_domain, files_to_generate)
    elif not ext:
        check_dir(url, last_modified_domain, files_to_generate)

def check_dir(url, last_modified_domain, files_to_generate):
    doc = parse(url).getroot()
    doc.make_links_absolute()
    links = doc.xpath("//a[@href]/@href")
    for link in links:
        if not link == url and link.startswith(url):
            check_url(link, last_modified_domain, files_to_generate)

def check_xml(url, last_modified_domain, files_to_generate):
    r = requests.head(url)
    last_modified_on_oac_header = r.headers['last-modified']
    last_modified_on_oac = boto.utils.parse_ts(last_modified_on_oac_header)
    # if the URL is not in the last_modified_domain OR last-modified is later than the database; add
    # the file to the list of files to be processed
    last_modified_item = last_modified_domain.get_item(url)
    if not last_modified_item:
        if last_modified_on_oac > datetime.datetime(2013,07,01):
            add_to_list(url, last_modified_on_oac, last_modified_domain, files_to_generate)
    elif last_modified_on_oac > datetime.datetime.strptime(last_modified_item['last_modified'], DATE_FMT):
        add_to_list(url, last_modified_on_oac, last_modified_domain, files_to_generate)
        
def add_to_list(url, url_last_modified, last_modified_domain, files_to_generate):
    files_to_generate.append(url)
    # TODO: create/update the simplebd item with the new timestamp and batchID
    logging.info("ADDING TO WORK LIST:%s %s" % (url, url_last_modified))
    attrs = {'last_modified':datetime.datetime.strftime(url_last_modified, DATE_FMT)}
    last_modified_domain.put_attributes(url, attrs)

def launch_ec2():
    user_data = generate_cloudinit()
    connection = boto.connect_ec2()
    reservation = connection.request_spot_instances(
                                       "1.00",
                                       "ami-05355a6c", # check http://aws.amazon.com/amazon-linux-ami/ for current AMI
                                       key_name="majorTom-keypair",
                                       user_data=user_data,
                                       placement="us-east-1b",
                                       instance_profile_arn="arn:aws:iam::563907706919:instance-profile/s3-read-write",
                                       #instance_type="m3.2xlarge")   #   1.00/hr    8vCPU       26 ECPU     30 G RAM
                                       instance_type="t1.micro")   #   1.00/hr    8vCPU       26 ECPU     30 G RAM
    spot_id = str(reservation[0].id)
    spot_reservation = connection.get_all_spot_instance_requests(spot_id)[0]
    while spot_reservation.instance_id == None:
        sleep(20)
        spot_reservation = connection.get_all_spot_instance_requests(spot_id)[0]

    r = connection.get_all_instances(spot_reservation.instance_id)
    hostname = r[0].instances[0].public_dns_name
    return spot_reservation.instance_id, hostname

def terminate_ec2(instance):
    connection = boto.connect_ec2()
    return connection.get_all_instances(instance)[0].instances[0].terminate()

def remote_process_pdf(hostname, files_to_generate):
    pp(files_to_generate)
    pp(hostname)
    # ssh to host
    # poll for cloudinit to stop (or refactor not to use cloudinit; do that from here)
    # use xargs -P to process PDF files on remote machine
    return

def generate_cloudinit():
    script="""
#!/bin/bash
# cloudinit script
# https://help.ubuntu.com/community/CloudInit
set -o pipefail  # trace ERR through pipes
set -o errtrace  # trace ERR through 'time command' and other functions
set -o nounset   ## set -u : exit the script if you try to use an uninitialised variable
set -o errexit   ## set -e : exit the script if any statement returns a non-true return value
yum -y update    # for security
yum -y install git
yum -y groupinstall "Development Tools"
easy_install pip
pip install virtualenv
yum -y install python-devel  # needed to install(init?) virtualenv with local python
yum -y install ncurses-devel # needed to install pkgsrc python
yum -y install openssl-devel
yum -y install libjpeg-devel
yum -y install freetype-devel
yum -y install libtiff-devel
yum -y install lcms-devel
yum -y install mercurial

su - ec2-user -c 'curl -L https://raw.github.com/ucldc/appstrap/master/cdl/ucldc-operator-keys.txt >> ~/.ssh/authorized_keys'

useradd pdfu

touch ~pdfu/init.sh
chown pdfu:pdfu ~pdfu/init.sh
chmod 700 ~pdfu/init.sh
# write the file
cat > ~pdfu/init.sh <<EOSETUP
#!/usr/bin/env bash
set -eu
cd
git clone https://github.com/tingletech/pdfu.git
./pdfu/init.sh
"""
    return script

def vorotos3url(url):
    dir, ext = os.path.splitext(url)
    fixup = url.replace('http://voro.cdlib.org/oac-ead/prime2002/','s3://pdf-generation/pdfs/')
    return u"%s.pdf" % ( os.path.splitext(fixup)[0] )

def main(url_check_root, loglevel='ERROR'):
    numeric_level = getattr(logging, loglevel.upper(), None)
    if not isinstance(numeric_level, int):
        raise ValueError('Invalid log level: %s' % argv.loglevel)
    logging.basicConfig(level=numeric_level, )
    url_check_root = url_check_root.strip()
    sdb = boto.connect_sdb()
    last_modified_domain = sdb.get_domain('ead_last_modified')
    files_to_generate = []
    check_url(url_check_root, last_modified_domain, files_to_generate)
# files to generate will be filled up; can now launch an EC2 and run the batch
    if files_to_generate:
        pp.pprint(files_to_generate)
        instance, hostname = launch_ec2()
        remote_process_pdf(hostname, files_to_generate)
        terminate_ec2(instance)

if __name__=='__main__':
    if len(sys.argv) < 2:
        print "Usage: check_last_modfied <root url to check> --loglevel='DEBUG'"
        sys.exit(1)
    parser = optparse.OptionParser()
    parser.add_option("-l", "--loglevel", dest="loglevel", help="logging module level", default='ERROR')
    (options, args) = parser.parse_args()
    main(args[0], loglevel=options.loglevel)
