#!/usr/bin/env python
""" pdfshadow
    creates shadow directory structure for XTF
"""
from __future__ import unicode_literals
import sys
import os
import argparse
import logging
import boto
import urlparse
import tarfile
import StringIO
import time

def main(argv=None):

    parser = argparse.ArgumentParser( description='create shadow directory for XTF', 
                                      epilog='XTF can check this' )
    parser.add_argument('bucket', nargs=1, help="s3://bucket[/optional/path]")
    parser.add_argument('archive', nargs=1, help="filename for .tar.gz shadow file" )
    parser.add_argument('--prefix', default='pdf-shadow', required=False, help="path the .tar.gz will unpack to")

    if argv is None:
        argv = parser.parse_args()

    # call the function that does the work
    shadow(argv.bucket[0], argv.archive[0], argv.prefix)

def shadow(bucketurl, archive, prefix):
    parts = urlparse.urlsplit(bucketurl)  # SplitResult(scheme='s3', netloc='test.pdf', path='/dkd', query='', fragment='')
    s3 = boto.connect_s3()
    bucket = s3.get_bucket(parts.netloc)
    tar = tarfile.open(archive, "w:gz")
    for key in bucket.list():
        # look for pdfs that match the user supplied path
        if key.name.endswith(u'.pdf') and not parts.path or key.name.startswith(parts.path[1:]):
            # write directly to a tar file http://stackoverflow.com/a/740839/1763984
            shadowfile = StringIO.StringIO()
            shadowfile.write(str(key.size))
            shadowfile.seek(0)
            shadowname = os.path.join(prefix, os.path.splitext(key.name)[0])
            info = tarfile.TarInfo(shadowname)
            info.size = len(shadowfile.buf)
            # boto last_modified to Datetime http://stackoverflow.com/a/9688496/1763984
            # Datetime to unixtime http://stackoverflow.com/a/255053/1763984
            info.mtime = time.mktime(boto.utils.parse_ts(key.last_modified).timetuple())
            tar.addfile(tarinfo=info, fileobj=shadowfile)
            shadowfile.close()

# main() idiom for importing into REPL for debugging 
if __name__ == "__main__":
    sys.exit(main())
